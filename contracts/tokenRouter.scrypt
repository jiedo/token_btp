import "util.scrypt";
import "tokenProto.scrypt";
import "txUtil.scrypt";
import "rabinUtil.scrypt";

contract TokenRouter {
    int rabinPubKey;
    int nReceivers;
    bytes receivers;
    bytes receiverTokenAmounts;

    public function unlock(
        SigHashPreimage txPreimage,
        int nSenders,
        bytes rabinMsgs,
        bytes paddings,
        bytes sigs, // TODO: sig length
        bytes outputSatoshis,
        bytes prevouts,
        bytes prevInputTxs
    ) {
        SigHashType sigHashType = SigHash.ALL | SigHash.FORKID;
        require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

        require(hash256(prevouts) == Util.hashPrevouts(txPreimage));

        // TODO: verify the input token
        int i = 0;
        int sumInputToken = 0;
        int paddingPos = 0;
        int prevInputTxsPos = 0;
        bytes tokenScript = b'';
        loop(5) {
            if (i < nSenders) {
                // verify the rabin sig
                bytes msg = rabinMsgs[i * RabinUtil.RABIN_MSG_LEN: (i + 1) * RabinUtil.RABIN_MSG_LEN];
                int paddingLen = Util.fromLEUnsigned(paddings[paddingPos: paddingPos + 1]);
                bytes padding = b'';
                if (paddingLen > 0) {
                    padding = paddings[paddingPos + 1: paddingPos + 1 + paddingLen];
                }
                paddingPos = paddingPos + 1 + paddingLen;
                int h = Util.fromLEUnsigned(RabinUtil.rabinHash(msg + padding));
                int sig = Util.fromLEUnsigned(sigs[i * RabinUtil.RABIN_SIG_LEN: (i + 1) * RabinUtil.RABIN_SIG_LEN]);
                require((sig * sig) % this.rabinPubKey == h % this.rabinPubKey);

                // verify input tx
                bytes inputTxId = prevouts[(i + 1) * TxUtil.OUTPOINT_LEN: (i + 1) * TxUtil.OUTPOINT_LEN + TxUtil.TX_ID_LEN];
                int inputTxOutputIdx = Util.fromLEUnsigned(prevouts[(i + 1) * TxUtil.OUTPOINT_LEN + TxUtil.TX_ID_LEN: (i + 2) * TxUtil.OUTPOINT_LEN]);

                // get prev input Tx
                int prevInputTxLen = Util.fromLEUnsigned(prevInputTxs[prevInputTxsPos: prevInputTxsPos + 4]);
                bytes prevInputTx = prevInputTxs[prevInputTxsPos + 4: prevInputTxsPos + 4 + prevInputTxLen];
                prevInputTxsPos = prevInputTxsPos + 4 + prevInputTxLen;

                require(inputTxId == RabinUtil.getMsgTxId(msg));
                require(hash256(prevInputTx) == inputTxId);

                bytes inputScriptCode = TxUtil.readOutputScript(prevInputTx, inputTxOutputIdx);
                int inputTokenAmount = TokenProto.getTokenValue(inputScriptCode, len(inputScriptCode));
                tokenScript = inputScriptCode;
                
                sumInputToken = sumInputToken + inputTokenAmount;
            }
            i = i + 1;
        }

        // check the outputs
        bytes outputs = b'';
        // max support 5 receiver, you can change this num, but will cause the contrac size increase. you can customize your output
        i = 0;
        int sumOutputToken = 0;
        loop(5) {
            if (i < this.nReceivers) {
                bytes address = this.receivers[i * TokenProto.TOKEN_ADDRESS_LEN: (i + 1) * TokenProto.TOKEN_ADDRESS_LEN];
                int tokenAmount = Util.fromLEUnsigned(this.receiverTokenAmounts[i * TokenProto.TOKEN_VALUE_LEN: (i + 1) * TokenProto.TOKEN_VALUE_LEN]);
                sumOutputToken = sumOutputToken + tokenAmount;
                bytes outputScript = TokenProto.getNewTokenScript(tokenScript, len(tokenScript), address, tokenAmount);
                int outputSatoshi = Util.fromLEUnsigned(outputSatoshis[i * 8: (i + 1) * 8]);
                bytes output = Util.buildOutput(outputScript, outputSatoshi);
                outputs = outputs + output;
            }
            i = i + 1;
        }
        require(sumInputToken == sumOutputToken);
        bytes hashOutputs = hash160(outputs);
        require(hashOutputs == Util.hashOutputs(txPreimage));
    }
}