import "util.scrypt";
import "tokenProto.scrypt";
import "txUtil.scrypt";
import "rabinUtil.scrypt";

contract TokenRouter {
    int rabinPubKey;
    int nReceivers;
    bytes receiverArray;
    bytes receiverTokenAmountArray;

    public function unlock(
        SigHashPreimage txPreimage,
        int nSenders,
        bytes rabinMsgArray,
        bytes paddingArray,
        bytes sigArray, // sig array
        bytes outputSatoshiArray, // satoshi array 
        bytes prevouts,
        bytes tokenScript // one token input script code
    ) {
        SigHashType sigHashType = SigHash.ALL | SigHash.FORKID;
        require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

        require(hash256(prevouts) == Util.hashPrevouts(txPreimage));

        int scriptLen = len(tokenScript);
        bytes contractHash = hash160(TokenProto.getContractCode(tokenScript, scriptLen));

        int i = 0;
        int sumInputToken = 0;
        int paddingPos = 0;
        // max support loop num input token
        loop(3) {
            if (i < nSenders) {
                // verify the rabin sig
                bytes msg = rabinMsgArray[i * RabinUtil.RABIN_MSG_LEN: (i + 1) * RabinUtil.RABIN_MSG_LEN];
                int paddingLen = Util.fromLEUnsigned(paddingArray[paddingPos: paddingPos + 1]);
                bytes padding = b'';
                if (paddingLen > 0) {
                    padding = paddingArray[paddingPos + 1: paddingPos + 1 + paddingLen];
                }
                paddingPos = paddingPos + 1 + paddingLen;
                int h = RabinUtil.rabinHash(msg + padding);
                int sig = Util.fromLEUnsigned(sigArray[i * RabinUtil.RABIN_SIG_LEN: (i + 1) * RabinUtil.RABIN_SIG_LEN]);
                require((sig * sig) % this.rabinPubKey == h % this.rabinPubKey);

                // verify input tx
                bytes inputTxId = prevouts[(i + 1) * TxUtil.OUTPOINT_LEN: (i + 1) * TxUtil.OUTPOINT_LEN + TxUtil.TX_ID_LEN];
                int inputTxOutputIdx = Util.fromLEUnsigned(prevouts[(i + 1) * TxUtil.OUTPOINT_LEN + TxUtil.TX_ID_LEN: (i + 2) * TxUtil.OUTPOINT_LEN]);

                // get prev input Tx
                require(inputTxId == RabinUtil.getMsgTxId(msg));
                require(inputTxOutputIdx == RabinUtil.getMsgOutputIndex(msg));

                int inputTokenAmount = RabinUtil.getMsgTokenAmount(msg);

                
                require(contractHash == RabinUtil.getMsgContractHash(msg));
                
                sumInputToken = sumInputToken + inputTokenAmount;
            }
            i = i + 1;
        }

        // check the outputs
        bytes outputs = b'';
        // max support loop num receiver, you can change this num, but will cause the contrac size increase. you can customize your output
        i = 0;
        int sumOutputToken = 0;
        loop(3) {
            if (i < this.nReceivers) {
                bytes address = this.receiverArray[i * TokenProto.TOKEN_ADDRESS_LEN: (i + 1) * TokenProto.TOKEN_ADDRESS_LEN];
                int tokenAmount = Util.fromLEUnsigned(this.receiverTokenAmountArray[i * TokenProto.TOKEN_VALUE_LEN: (i + 1) * TokenProto.TOKEN_VALUE_LEN]);
                sumOutputToken = sumOutputToken + tokenAmount;
                bytes outputScript = TokenProto.getNewTokenScript(tokenScript, scriptLen, address, tokenAmount);
                int outputSatoshi = Util.fromLEUnsigned(outputSatoshiArray[i * 8: (i + 1) * 8]);
                bytes output = Util.buildOutput(outputScript, outputSatoshi);
                outputs = outputs + output;
            }
            i = i + 1;
        }
        require(sumInputToken == sumOutputToken);
        bytes hashOutputs = hash160(outputs);
        require(hashOutputs == Util.hashOutputs(txPreimage));
    }
}